# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Савина А.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В Прологе список - это рекурсивная структура данных, допускающая только последовательный доступ к её элементам. Таким образом элементы списка могут обрабатываться только рекурсивно, разделяя при обходе список на голову (Head) и хвост (Tail).  
В императивных языках список обычно явлется массивом. То есть к любым его элементам можно обращаться в произвольном порядке.  
Однако списки в императивных языках могут содержать в себе лишь элементы одинакового типа. В Прологе же типы данных не играют такой огромной роли, как в императивных языках: можно сказать, что существует лишь один тип данных - term и что, по сути, переменные не являются типизированными и будут объединяться с другими терминами по необходимости. Числа, переменные, атомы, составные термины - это не типы данных, а разные типы терминов. Это позволяет в Прологе хранить в списке любые элементы.

Списки в Прологе очень похожи на двоичные деревья.  
Пусть в узлах дерева хранятся элементы списка, которыми могут быть любые объекты, или пустой список. При таком представлении список или состоит из двух частей (голова, хвост - список), или является пустым.

## Задание 1.1: Предикат обработки списка

1. `lasto(List, X)` - получает последний элемент списка (без стандартных предикатов)

Примеры использования:
```prolog
?- lasto([1, 2, 3, 4], X).
X = 4 .
?- lasto([1], X).
X = 1 .
?- lasto([3, 4, 5, -3], X).
X = -3 .
?- lasto([], X).
false.
?- lasto([5, 3, 8, 992], 992).
true .
```

Реализация:
```prolog
lasto([X], X).
lasto([_|T], X) :-
	lasto(T, X).
```

* Если в списке только X элемент, то он и является последним;
* Рекурсивно "отбрасывая" голову списка, проходим по нему. В конце концов T станет списком с одним элементом;
* Список не должен быть пустой.  

2. `lastoo(List, X)` - получает последний элемент списка (со стандартными предикатами)

Примеры использования:
```prolog
?- lastoo([1, 2, 3, 4], X).
X = 4 .
?- lastoo([], X).
false.
?- lastoo([5, 3, 8, 992], 992).
true .
?- lastoo([3, 4, 5, -3], X).
X = -3 .
?- lastoo([92], X).
X = 92 .
```

Реализация:
```prolog
lastoo(Z, X) :- 
	append(_, [X], Z).
```

* Если Z - это конкатенация анонимной переменной и списка, состоящего из одного элемента X, то X - последний элемент.

## Задание 1.2: Предикат обработки числового списка

Скалярное произведение векторов - сумма попарного произведения их координат.

1. `scalar(L1, L2, X)` - вычисление скалярного произведения двух векторов-списков (с учетом возможного несовпадения размерностей) (без стандартных предикатов)

Примеры использования:
```prolog
?- scalar([1, 2, 3], [4, 3, 5], 25).
true.
?- scalar([1, 2, 3, 4], [4, 3, 5, 3], X).
X = 37.
?- scalar([1], [2], X).
X = 2.
?- scalar([0], [2], X).
X = 0.
?- scalar([], [2], X).
false.
?- scalar([3], [], X).
false.
```

Реализация:
```prolog
%lengtho: 1) the length of the empty list is 0;
%	  2) if the length of a X is N1 and N = N1+1, the list of any head and of X tail has the length of N.
lengtho([], 0).
lengtho([_|X], N) :-
	lengtho(X, N1),
	N is N1+1.

complen(L1, L2) :-
	lengtho(L1, N),
	lengtho(L2, C),
	N =:= C.

ssum([], [], 0). 
ssum([H1|T1], [H2|T2], X) :-
	C is H1*H2,
	ssum(T1, T2, X1),
	X is X1 + C. 	

scalar(L1, L2, X) :-
	complen(L1, L2),
	ssum(L1, L2, X).
```

* `complen(L1, L2)`: проверяет спиcки на совпадение размерностей, используя `lengtho(L, N)` - реализацию стандартного предиката `length(L, N)`;
* `ssum(L1, L2, Sum)`: умножает головы списков. Затем, рекурсивно "отбрасывая" головы, проходит по ним и складывает получившиеся произведения. Так как при рекурсивном прохождении в конце оба листа будут пустыми, то необходимо это предусмотреть;
* `scalar(L1, L2, X)`: объединяет проверку на размерность и само скалярное произведение.

2. `scalar1(L1, L2, X)` - вычисление скалярного произведения двух векторов-списков (с учетом возможного несовпадения размерностей) (со стандартными предикатами)

Примеры использования:
```prolog
?- scalar1([1], [2], X).
X = 2.
?- scalar1([1, 3], [2], X).
false.
?- scalar1([1, 3, 4], [2, 5, -3], X).
X = 5.
?- scalar1([1, 3, 4], [2, 5, 3], 29).
true.
?- scalar1([], [3], X).
false.
```

Реализация:
```prolog
scalar1(L1, L2, X) :-
	same_length(L1, L2),
	ssum(L1, L2, X).
```
* Используя стандартный предикат `same_length(L1, L2)`, сравниваем размерности;
* С помощью `ssum(L1, L2, Sum)` вычисляем скалярное произведение.
## Задание 2: Реляционное представление данных

Основная идея реляционной модели - описание данных как совокупности предикатов (отношений) над конечным набором предикатных переменных. Запрос информации к таким данным тоже является предикатом. А результат - множество ответов, удовлетворяющих заданной структуре программы.  
Анализ отношений, описание ограничений, правил на возможные значения и комбинации значений - реализация необходимой структуры, которую необходимо осуществить самому.  
Работать с реляционным представлением в Прологе достаточно удобно, так как такая модель прежде всего нацелены на человека - проста для понимания. Это позволяет 'делить' программу на компоненты (правила), реализация которых в общем случае не зависит друг от друга (в другом случае можно заменить ещё не написанные компоненты можеством фактов), тут же тестировать программу и быстрее находить ошибки в необходимом компоненте.  
К недостаткам реляционного представления можно отнести сложность и громоздкость правил, если предикаты-факты будут плохо заданы.  
Именно это принесло главное неудобство при выполнении задания.
  
Представление из four.pl можно 'разделить' на 2 части: списки студентов в группах и журналы успеваемости по предметам.  
К фактам, связывающим студента и оценку и находящимся внутри списка, внутри журнала по определённому предмету, нельзя обратиться просто так. В списках можно хранить термины, а не факты, следовательно те факты являются терминами. Это значит, что пользоваться ими можно только во время прохождения через список. Именно этот обход порождает 'трёхслойные' или более правила, не очень лёгкие для понимания и поиска проблем. Если бы вместо журналов успеваемости были факты с предметом, студентом и оценкой, то правила были бы проще.  
Однако списки групп оказались очень удобными. Они позволили легче ориентироваться в журналах успеваемости.


1.1) Для каждого студента найти средний балл

Примеры использования:
```prolog
?- average('Петров', X).
X = 3.6666666666666665.
?- average('Эфиркина', X).
X = 4.166666666666667.
?- average('Шарпин', X).
X = 4.
```

Реализация:
```prolog
studsearch([], _, 0).
studsearch([grade(X, Y)|_], Stud, M) :-
	X == Stud, !,
	M is Y.
studsearch([_|T], Stud, N) :-
	studsearch(T, Stud, N).
	
avs(Stud, X) :-
	subject(_, Y),
	studsearch(Y, Stud, X).

average(Stud, S) :-
	bagof(X, avs(Stud, X), L),
	sum_list(L, SL),
	length(L, LL),
	S is SL / LL.
```
* `avs(Stud, X)`: возвращает оценки заданного студента (Stud) по всем предметам;
* `studsearch(L, Stud, M)`: возвращает оценки (M) студента (Stud), исходя из заданного списка-журнала (M). Так как список-журнал состоит из терминов `grade(X, Y)`, то, только рекурсивно проходя по списку, мы можем работать с X (фамилия студента) и Y (его оценка).  
Использование отсечения(!) позволяет создавать взаимоисключающие правила, то есть утверждения типа: если А, то В, иначе - С.  
Обозначим `studsearch([], _, 0)` как условие 'a'. 'a' говорит о том, что если в studsearch пустой список и какой-нибудь студент, то оценка этого студента по данному предмету будет - 0 (оценки нет, по сути).  
Условие 'b': проверка на совпадение фамилии рассматриваемого студента с нужной фамилией.  
Третье условие обозначим как 'c': M это и есть полученная в ходе запроса оценка.  
Последнее условие - 'd' необходимо для рекурсивного обхода списка, если фамилии студентов не совпадают ('a' не выполняется).  
В итоге получаем: `studsearch(L, Stud, M)` <=> a U (b & c) U (~b & d);  
* `average(Stud, S)`: объединяет оценки студента в список, находит сумму элементов списка, длину списка, делит сумму на длину и выводит результат - средний бал студента.  
Так как `avs(Stud, X)` выдаёт множество решений, увидеть которые можно с помощью автоматического перебора, то для работы с ними целесообразно собрать их в список. `bagof(X, P, L)` порождает список L всех объектов X, удовлетворяющих цели P (в данном случае - `avs(Stud, X)`, цель - X).  
Сумма, длина списка вычисляются при помощи стандартных предикатов.

1.2) Для каждого студента найти сдал ли он экзамены или нет

Примеры использования:
```prolog
?- fcheck('Петров', X).
X = 'Логическое программирование' ;
X = 'Функциональное программирование' ;
X = 'Информатика' ;
X = 'Английский язык' ;
X = 'Психология'.
?- fcheck('Петров', 'Математический анализ').
false.
?- fcheck('Шарпин', 'Математический анализ').
true.
?- fcheck('Азурин', X).
X = 'Логическое программирование' ;
X = 'Математический анализ' ;
X = 'Функциональное программирование' ;
X = 'Информатика' ;
X = 'Психология'.
```

Реализация:
```prolog
fcheck(Stud, Sub) :-
	subject(Sub, Y),
	studsearch(Y, Stud, M),
	M > 2.
```
* При помощи `studsearch(Y, Stud, M)` (описан выше) находим оценку по предмету (Sub). Y - список-журнал оценок по предмету. Если эта оценка больше 2, то студент (Stud) сдал экзамен (true). В другом случае - false. Ещё можно при помощи автоматического перебора посмотреть, какие именно предметы сдал студент.

2) Для каждого предмета найти количество несдавших студентов

Примеры использования:
```prolog
?- fail('Психология', X).
X = 2.
?- fail('Логическое программирование', X).
X = 3.
?- fail('Функциональное программирование', 2).
false.
?- fail('Функциональное программирование', 0).
true.
?- fail('Информатика', 2).
true.
?- fail(X, 1).
X = 'Математический анализ' .
?- fail(X, 2).
X = 'Информатика' ;
X = 'Английский язык' ;
X = 'Психология'.
```

Реализация:
```prolog
fcount([], 0).
fcount([grade(_, Y)|T], C) :-
	Y < 3, !,
	fcount(T, N),
	C is N + 1.
fcount([_|T], N) :-
	fcount(T, N).

fail(Sub, X) :-
	subject(Sub, L),
	fcount(L, X).
```
* `fcount(L, X)`: выводит количество несдавших студентов, исходя из журнала-списка L.  
Логика применения отсечения такая же, как в предикате `studsearch(L, Stud, M)`:  
'a' - условие для пустого списка. Оценка равна 0;  
'b' - проверка на сдачу (оценка Y должна быть меньше 3);  
'c' - снова вызываем fcount для рекурсии (если получил 2) и увеличиваем counter на 1;  
'd' - необходимо для рекурсии в случае сдачи студента;
* `fail(Sub, X)`: обозначает журнал-список, соответствующий необходимому предмету (Sub), вызывает fcount. C помощью этого предиката можно узнать, сколько студентов не сдало предмет и какие предметы не сдало определённое количество студентов.

3) Для каждой группы найти студента (студентов) с максимальным средним баллом

Примеры использования:
```prolog
? - gmax(101).
Мышин
true.
?- gmax(103).
Текстописова
true.
?- gmax(104).
Фулл
Джаво
Запорожцев
true.
?- gmax(105).
false.
?- gmax(102).
Биткоинов
true.
```

Реализация:
```prolog
avg([H|_], X) :-
	average(H, X).
avg([_|T], X) :-
	avg(T, X).

checkMax([], _).	
checkMax([H|T], Max) :-
	average(H, A),
	A =:= Max, !,
	checkMax(T, Max),
	write(H), nl.
checkMax([_|T], Max) :-
	checkMax(T, Max).

gmax(N) :-
	group(N, Y),
	bagof(M, avg(Y, M), L),
	max_list(L, Max),
	checkMax(Y, Max).
```
* `avg(L, X)`: возвращает средний балл всех студентов списка-группы, используя предикат `average(Stud, X)`и рекурсию;
* `checkMax(L, Max)`: печатает студентов с максимальным средним баллом из группы.  
Логика применения отсечения такая же, как в предикате `studsearch(L, Stud, M)`:  
'a' - предикат для пустого списка;  
'b' - проверка на совпадение среднего балла студента и Max;  
'c' - вызов checkMax с хвостом списка (ведь студентов с максимальным средним баллом может быть несколько) и распечатка полученной головы - фамилии студента;  
'd' - необходимо для рекурсии, если средний балл меньше максимального;  
* `gmax(N)`: объединяет средние баллы студентов определённой группы (N) в список (L) (`bagof(X, P, L)`), ищет максимальный средний балл из этого списка с помощью стандартного предиката `max_list(L, Max)` и вызывает  `checkMax(Y, Max)` со списком-группой (Y) и полученным максимальным баллом.
## Выводы

При использовании императивных языков необходимо указать, как делать ту или иную задачу, а в Прологе - описать, какую задачу нужно решать.  
Благодаря реляционности Пролога выполнение заданий сводилось к написанию фактов и правил. Вроде бы всё кажется легким, но логика обработки и тех, и других порой сильно озадачивает.  
Сложную задачу иногда приходится 'дробить' на более простые, разбираться в работе каждой из них. Но и этого бывает недостаточно. Тогда трассировка спасает от потери в море информации. trace - главный помощник в понимании того, что вообще происходит при определённом запросе, как работают созданные правила и где найти ошибки.  
  
До этого года я никогда пользовалась языками с элементами декларативного стиля, поэтому слабо представляю, к чему можно практически применить мои начальные знания о Прологе(кроме реализации реляционных баз данных и ещё каких-то тривиальных задач). Дальнейшее изучение, надеюсь, поможет ответить на этот вопрос, но последующие лабораторные работы немного пугают. Впрочем, самое страшное - то, что написание отчёта заняло больше времени, чем выполнение всего задания.  

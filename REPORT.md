# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Савина А.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Опишите своими словами, чем списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных. На какие структуры
данных в традиционных языках похожи списки в Прологе?

## Задание 1.1: Предикат обработки списка

1. `lasto(List, X)` - получает последний элемент списка (без стандартных предикатов)

Примеры использования:
```prolog
?- lasto([1, 2, 3, 4], X).
X = 4 .
?- lasto([1], X).
X = 1 .
?- lasto([3, 4, 5, -3], X).
X = -3 .
?- lasto([], X).
false.
?- lasto([5, 3, 8, 992], 992).
true .
```

Реализация:
```prolog
lasto([X], X).
lasto([_|T], X) :-
	lasto(T, X).
```

* Если в списке только X элемент, то он и является последним;
* Рекурсивно "отбрасывая" голову списка, проходим по нему. В конце концов T станет списком с одним элементом;
* Список не должен быть пустой.  

2. `lastoo(List, X)` - получает последний элемент списка (со стандартными предикатами)

Примеры использования:
```prolog
?- lastoo([1, 2, 3, 4], X).
X = 4 .
?- lastoo([], X).
false.
?- lastoo([5, 3, 8, 992], 992).
true .
?- lastoo([3, 4, 5, -3], X).
X = -3 .
?- lastoo([92], X).
X = 92 .
```

Реализация:
```prolog
lastoo(Z, X) :- 
	append(_, [X], Z).
```

* Если Z - это конкатенация анонимной переменной и списка, состоящего из одного элемента X, то X - последний элемент.

## Задание 1.2: Предикат обработки числового списка

Скалярное произведение векторов - сумма попарного произведения их координат.

1. `scalar(L1, L2, X)` - вычисление скалярного произведения двух векторов-списков (с учетом возможного несовпадения размерностей) (без стандартных предикатов)

Примеры использования:
```prolog
?- scalar([1, 2, 3], [4, 3, 5], 25).
true.
?- scalar([1, 2, 3, 4], [4, 3, 5, 3], X).
X = 37.
?- scalar([1], [2], X).
X = 2.
?- scalar([0], [2], X).
X = 0.
?- scalar([], [2], X).
false.
?- scalar([3], [], X).
false.
```

Реализация:
```prolog
complen(L1, L2) :-
	lengtho(L1, N),
	lengtho(L2, C),
	N =:= C.

ssum([], [], 0). 
ssum([H1|T1], [H2|T2], X) :-
	C is H1*H2,
	ssum(T1, T2, X1),
	X is X1 + C. 	

scalar(L1, L2, X) :-
	complen(L1, L2),
	ssum(L1, L2, X).
```

* `complen(L1, L2)`: проверяет спиcки на совпадение размерностей, используя `lengtho(L, N)` - реализацию стандартного предиката `length(L, N)`;
* `ssum(L1, L2, Sum)`: умножает головы списков, рекурсивно "отбрасывая" головы, проходим по ним и складывает получившиеся произведения. Так как при рекурсивном прохождении в конце оба листа будут пустыми, то необходимо это предусмотреть;
* `scalar(L1, L2, X)`: объединяет проверку на размерность и само скалярное произведение.

2. `scalar1(L1, L2, X)` - вычисление скалярного произведения двух векторов-списков (с учетом возможного несовпадения размерностей) (со стандартными предикатами)

Примеры использования:
```prolog
?- scalar1([1], [2], X).
X = 2.
?- scalar1([1, 3], [2], X).
false.
?- scalar1([1, 3, 4], [2, 5, -3], X).
X = 5.
?- scalar1([1, 3, 4], [2, 5, 3], 29).
true.
?- scalar1([], [3], X).
false.
```

Реализация:
```prolog
scalar1(L1, L2, X) :-
	same_length(L1, L2),
	ssum(L1, L2, X).
```
* Используя стандартный предикат `same_length(L1, L2)`, сравниваем размерности;
* С помощью `ssum(L1, L2, Sum)` вычисляем скалярное произведение.
## Задание 2: Реляционное представление данных

Опишите, в чем преимущества и недостатки реляционного представления в целом, и конкретного представления, которое вы использовали.

Опишите принцип реализации всех предикатов, осуществляющих запросы к данным.

## Выводы

Сформулируйте *содержательные* выводы по лабораторной работе. Чему она вас научила? Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную.





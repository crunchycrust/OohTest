# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Савина А.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Опишите своими словами, чем списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных. На какие структуры
данных в традиционных языках похожи списки в Прологе?

## Задание 1.1: Предикат обработки списка

1. `lasto(List, X)` - получает последний элемент списка (без стандартных предикатов)

Примеры использования:
```prolog
?- lasto([1, 2, 3, 4], X).
X = 4 .
?- lasto([1], X).
X = 1 .
?- lasto([3, 4, 5, -3], X).
X = -3 .
?- lasto([], X).
false.
?- lasto([5, 3, 8, 992], 992).
true .
```

Реализация:
```prolog
lasto([X], X).
lasto([_|T], X) :-
	lasto(T, X).
```

* Если в списке только X элемент, то он и является последним;
* Рекурсивно "отбрасывая" голову списка, проходим по нему. В конце концов T станет списком с одним элементом;
* Список не должен быть пустой.  

2. `lastoo(List, X)` - получает последний элемент списка (со стандартными предикатами)

Примеры использования:
```prolog
?- lastoo([1, 2, 3, 4], X).
X = 4 .
?- lastoo([], X).
false.
?- lastoo([5, 3, 8, 992], 992).
true .
?- lastoo([3, 4, 5, -3], X).
X = -3 .
?- lastoo([92], X).
X = 92 .
```

Реализация:
```prolog
lastoo(Z, X) :- 
	append(_, [X], Z).
```

* Если Z - это конкатенация анонимной переменной и списка, состоящего из одного элемента X, то X - последний элемент.

## Задание 1.2: Предикат обработки числового списка

Скалярное произведение векторов - сумма попарного произведения их координат.

1. `scalar(L1, L2, X)` - вычисление скалярного произведения двух векторов-списков (с учетом возможного несовпадения размерностей) (без стандартных предикатов)

Примеры использования:
```prolog
?- scalar([1, 2, 3], [4, 3, 5], 25).
true.
?- scalar([1, 2, 3, 4], [4, 3, 5, 3], X).
X = 37.
?- scalar([1], [2], X).
X = 2.
?- scalar([0], [2], X).
X = 0.
?- scalar([], [2], X).
false.
?- scalar([3], [], X).
false.
```

Реализация:
```prolog
complen(L1, L2) :-
	lengtho(L1, N),
	lengtho(L2, C),
	N =:= C.

ssum([], [], 0). 
ssum([H1|T1], [H2|T2], X) :-
	C is H1*H2,
	ssum(T1, T2, X1),
	X is X1 + C. 	

scalar(L1, L2, X) :-
	complen(L1, L2),
	ssum(L1, L2, X).
```

* `complen(L1, L2)`: проверяет спиcки на совпадение размерностей, используя `lengtho(L, N)` - реализацию стандартного предиката `length(L, N)`;
* `ssum(L1, L2, Sum)`: умножает головы списков. Затем, рекурсивно "отбрасывая" головы, проходит по ним и складывает получившиеся произведения. Так как при рекурсивном прохождении в конце оба листа будут пустыми, то необходимо это предусмотреть;
* `scalar(L1, L2, X)`: объединяет проверку на размерность и само скалярное произведение.

2. `scalar1(L1, L2, X)` - вычисление скалярного произведения двух векторов-списков (с учетом возможного несовпадения размерностей) (со стандартными предикатами)

Примеры использования:
```prolog
?- scalar1([1], [2], X).
X = 2.
?- scalar1([1, 3], [2], X).
false.
?- scalar1([1, 3, 4], [2, 5, -3], X).
X = 5.
?- scalar1([1, 3, 4], [2, 5, 3], 29).
true.
?- scalar1([], [3], X).
false.
```

Реализация:
```prolog
scalar1(L1, L2, X) :-
	same_length(L1, L2),
	ssum(L1, L2, X).
```
* Используя стандартный предикат `same_length(L1, L2)`, сравниваем размерности;
* С помощью `ssum(L1, L2, Sum)` вычисляем скалярное произведение.
## Задание 2: Реляционное представление данных

Опишите, в чем преимущества и недостатки реляционного представления в целом, и конкретного представления, которое вы использовали.

Опишите принцип реализации всех предикатов, осуществляющих запросы к данным.

1.1) Для каждого студента, найти средний балл

Примеры использования:
```prolog
?- average('Петров', X).
X = 3.6666666666666665.
?- average('Эфиркина', X).
X = 4.166666666666667.
?- average('Шарпин', X).
X = 4.
```

Реализация:
```prolog
studsearch([], _, 0).
studsearch([grade(X, Y)|T], Stud, M) :-
	X == Stud, !,
	studsearch(T, Stud, N),
	M is Y + N.
studsearch([_|T], Stud, N) :-
	studsearch(T, Stud, N).

avs(Stud, X) :-
	subject(_, Y),
	studsearch(Y, Stud, X).

average(Stud, S) :-
	bagof(X, avs(Stud, X), L),
	sum_list(L, SL),
	length(L, LL),
	S is SL / LL.
```
*
*

1.2) Для каждого студента, найти сдал ли он экзамены или нет

Примеры использования:
```prolog
?- fcheck('Петров', X).
X = 'Логическое программирование' ;
X = 'Функциональное программирование' ;
X = 'Информатика' ;
X = 'Английский язык' ;
X = 'Психология'.
?- fcheck('Петров', 'Математический анализ').
false.
?- fcheck('Шарпин', 'Математический анализ').
true.
?- fcheck('Азурин', X).
X = 'Логическое программирование' ;
X = 'Математический анализ' ;
X = 'Функциональное программирование' ;
X = 'Информатика' ;
X = 'Психология'.
```

Реализация:
```prolog
fcheck(Stud, Sub) :-
	subject(Sub, Y),
	studsearch(Y, Stud, M),
	M > 2.
```
*
*

2) Для каждого предмета, найти количество не сдавших студентов

Примеры использования:
```prolog
?- fail('Психология', X).
X = 2.
 ?- fail('Логическое программирование', X).
X = 3.
?- fail('Функциональное программирование', 2).
false.
?- fail('Функциональное программирование', 0).
true.
?- fail('Информатика', 2).
true.
?- fail(X, 1).
X = 'Математический анализ' .
?- fail(X, 2).
X = 'Информатика' ;
X = 'Английский язык' ;
X = 'Психология'.
```

Реализация:
```prolog
fcount([], 0).
fcount([grade(_, Y)|T], C) :-
	Y < 3, !,
	fcount(T, N),
	C is N + 1.
fcount([_|T], N) :-
	fcount(T, N).

fail(Sub, X) :-
	subject(Sub, L),
	fcount(L, X).
```
*
*

3) Для каждой группы, найти студента (студентов) с максимальным средним баллом

Примеры использования:
```prolog
?- gmax(101, X).
Мышин
true.
 ?- gmax(103, X).
Текстописова
true.
?- gmax(104, X).
Фулл
Джаво
Запорожцев
true.
?- gmax(105, X).
false.
?- gmax(102, X).
Биткоинов
true.
```

Реализация:
```prolog
avg([H|_], X) :-
	average(H, X).
avg([_|T], X) :-
	avg(T, X).

checkMax([], _, 0).	
checkMax([H|T], Max, LM) :-
	average(H, A),
	A =:= Max, !,
	checkMax(T, Max, LM),
	write(H), nl.
checkMax([_|T], Max, _) :-
	checkMax(T, Max, _).

gmax(N, X) :-
	group(N, Y),
	bagof(M, avg(Y, M), L),
	max_list(L, Max),
	checkMax(Y, Max, X).
```

*
*

## Выводы

Сформулируйте *содержательные* выводы по лабораторной работе. Чему она вас научила? Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную.





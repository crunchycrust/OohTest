# Реферат
## по курсу "Логическое программирование"

### студент: Савина А.А.

## Логические языки и базы данных

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*
  
База данных, по сути, - это всего лишь организованное собрание информации. А система управления этой информацией называется системой управления базами данных (СУБД).  
Очень важно различать эти два понятия. База данных не может сразу быть представлена в виде аргументов процедур, функций какой-либо программы, поскольку она существует независимо от неё. Она вначале должна быть описана в соответствии с используемой СУБД определённым языком баз данных.  
Использование логики в базах данных началось в конце 1960-х годов.   
В ранних СУБД чаще всего выделялись следующие формальные логические языки:  
 1) Язык определения данных (DDL - Data Definition Language) используется для определения структур данных и схем базы данных. Его операторы используются для создания, изменения или удаления структур данных. Например, CREATE, ALTER, DROP;  
2) Язык определения хранилища (SDL - Storage Definition Language) используется для определения внутренней систем. Он определяет, какова будет физическая структура базы данных, сколько памяти уйдёт на её использование, как будут доступны записи, каков их порядок и т. д;
3) Язык определения представления (VDL - View Definition Language) нужен для указания пользовательских представлений и их отображения в концептуальной схеме. Он определяет подмножество записей, доступных пользователям, создает виртуальные таблицы, определяет пользовательские интерфейсы;  
4) Язык манипулирования данными (DML - Data Manipulation Language) используется на концептуальном уровне и на внешнем уровне для выполнения таких операций, как Query (запрос), Delete (удалить), Update (обновить) или Insert (вставить). Запросы, предназначенные только для чтения, иногда рассматриваются как часть DML. Язык манипулирования изменяет данные, но не системы и объекты баз данных.   
Этот язык далее можно разделить на два типа программирования:  
1) Процедурное программирование - программирование на императивных языках: оно содержит последовательность “шагов”, которые необходимо выполнить;  
2) Декларативное программирование: описывает логику вычислений без описания конкретных действий.  
  
В современных СУБД указанные выше языки обычно не разделяются, а используются как комплексный языки, включающие в себя конструкции концептуальной системы, представления данных и их манипуляции. Определения хранилища обычно хранится отдельно, так как оно используется для обозначения физических структур.  
Типичным примером всеобъемлющего языка баз данных является язык реляционных баз данных SQL (Structured Query Language), который представляет собой комбинацию DDL, VDL и DML, в нём также существуют операторы спецификации ограничений и многих других функций. В ранних версиях SQL SDL являлся его компонентом, но позже был удален из языка, чтобы сохранить SQL только на концептуальном и внешнем уровнях.  
  
Перед тем как перейти к наиболее широко распространённым, реляционным системам баз данных и разбору некоторых декларативных языков, хотелось бы упомянуть 3 ранних системы управления баз данных: инвертированные списки, иерархические и сетевые системы.
Эти системы активно использовались в течение многих лет. Но постепенно были вытеснены реляционными.    
Они не основывались на абстрактных моделях. Это понятие стало использоваться только с приходом реляционного подхода. Доступ к базам данных производился на уровне записей. Пользователи этих систем осуществляли ориентирование в базах данных, используя языки программирования, расширенные функциями систем управления базами данных. Интерактивный доступ к базам данных был возможен только при создании соответствующих прикладных программ.  
  
1)	Инвертированные списки.  
В общем случае — это двухуровневая индексная структура. Такие таблицы и их индексы виды пользователю. Операторы этой системы управления базы данных можно разделить на два типа:  
1.	Устанавливающие адрес записи. Например, прямые поисковые операторы (для нахождения записи в таблице по уже известному индексу); операторы, находящие запись в терминах относительно позиции от предыдущей записи по некоторому индексу.  
2.	Над адресуемыми записями. RETRIEVE (получить), DELETE (удалить), STORE (хранить), FIRST (первый по индексу) и другие.  
Такая организация доступа к данным используется во многих реляционных системах управления базами данных. Но в них пользователи не имеют непосредственного доступа к инвертированным спискам и индексам.  
	  
2)	Иерархические системы.  
Иерархические базы данных состоят из упорядоченного набора деревьев одного типа.  
Дерево состоит из одного "корневого" типа записи и упорядоченного набора из нуля или более типов поддеревьев, с информацией в узлах. То есть дерево в целом представляет собой иерархически организованный набор типов записи.  
Для такого вида баз данных существует особое правило: ребёнок не может существовать без родителя.  
Примеры операторов: найти указанное дерево, перейти от одного дерева к другому, от одной записи к другой в порядке иерархии, вставить новую запись, удалить запись и т. д.  
  
3)	Сетевые системы.  
Сетевые системы - это, по сути, расширение иерархических. В иерархической структуре ребёнок должен иметь только одного родителя, а в сетевой - ребёнок может иметь любое количество родителей.   
Сетевая система баз данных состоит из набора записей и связей (ребёнок или родитель) между этими записями.  
  
В ранних СУБД есть развитые средства управления данными во внешней памяти на низком уровне, возможность создания вручную эффективных прикладных систем для работы с базами данных.  
Однако их сложно использовать. Для этого необходимо знание императивных языков и физической организации систем управления базами данных.
	   
Для продвижения вперёд было необходимо формально описать базы данных, а не только языки их использования, и модель представления данных, нацеленную прежде всего на человека, а не на компьютер.  
  
В 1970 году Эдгар Кодд формализовал базы данных в терминах реляционного исчисления и реляционной алгебры. Он предоставил язык логики и реляционных исчислений, а также описал, как вычислять ответы на запросы в реляционной алгебре и реляционном исчислении. И реляционное исчисление, и реляционная алгебра предоставляют декларативные формализмы для определения запросов.   
Такое представление было значительно лучше сетевых и иерархических систем, которыми использовались лишь процедурные языки для баз данных.  
Реляционная алгебра и реляционное исчисление позволили людям, не разбирающимся в компьютерах, писать декларативные запросы и получать на них ответы.   
А развитие методов синтаксической оптимизации позволило системам реляционных баз данных эффективно получать ответы на запросы и всё больше вытеснять ранние системы.   
  
В реляционных СУБД данные организованны в виде набора таблиц, состоящих из столбцов и строк. В таблицах хранится информация об объектах, представленных в базе данных. В каждом столбце таблицы хранится определенный тип данных, в каждой ячейке – значение атрибута. Каждая строка таблицы представляет собой набор связанных значений, относящихся к одному объекту или сущности. Каждая строка в таблице может быть помечена уникальным идентификатором, называемым первичным ключом, а строки из нескольких таблиц могут быть связаны с помощью внешних ключей.  
Но это ведь звучит, как инвертированный список? Не всё так просто.   
Схема такой базы данных в концептуальном смысле - это набор отношений. Например, (имя_атрибута, значение). И такое описание позволяет представить базу данных формально, с помощью логических языков.  
  
Одно из самых известных формальных обозначений реляционной модели данных, пожалуй, принадлежит Кристоферу Дейту. В нём реляционная модель состоит из трех частей, описывающих разные аспекты реляционного подхода: структурной части, манипуляционной части и целостной части.   
В структурной части модели фиксируется, что единственной структурой данных, используемой в реляционных базах данных, является нормализованное n-арное отношение.  
В манипуляционной части - утверждаются два фундаментальных механизма манипулирования реляционными базами данных - реляционная алгебра и реляционное исчисление. Первый базируется в основном на классической теории множеств (с некоторыми уточнениями), а второй - на логическом аппарате исчисления предикатов первого порядка.  
И наконец, в целостной части должны соблюдаться два требования:  
1.	По сущности (любое отношение должно обладать первичным ключом);  
2.	По ссылкам (для каждого значения внешнего ключа, появляющегося в ссылающемся отношении, должно найтись отношение с таким же значением первичного ключа, иначе значение внешнего ключа не должно ни на что указывать - должно быть неопределённым).  
  
Механизмы реляционных баз данных замкнуты относительно понятия отношения. То есть выражения реляционной алгебры и формулы реляционного исчисления определены над отношениями и их результатом тоже являются отношения.  
Но между этими двумя понятиями существуют сильные различия.  
Выражения реляционной алгебры строятся на основе алгебраических операций, и подобно арифметическим и логическим выражениям выражение реляционной алгебры также имеют процедурную реализацию. То есть запрос на языке реляционной алгебры, может быть вычислен при осуществлении алгебраических операций с учетом их старшинства и возможного наличия скобок.   
А для реляционного исчисления нет однозначной интерпретации. Необходимо только установить условия, которым должны удовлетворять соответствующие отношения. Поэтому языки реляционного исчисления являются декларативными.  
  
Однако эти механизмы крайне редко используются по отдельности. Обычно языки баз данных являются некоторой смесью алгебраических и логических конструкций.  
		
  
Первое обобщение реляционных баз данных состояло в том, чтобы разрешить в базе данных беспроцедурные рекурсивные правила Хорна, то есть правила, в которых голова правила - это атом, а тело правила - это соединение атомов. Такие базы данных называются DDB или Datalog Databases.  
Одними из ранних разработчиков этого были Ван Эмден и Ковальски, которые в 1976 году написали статью о семантике теорий Хорна. Эти учёные внесли значительный вклад в логику и базы данных, обозначив, что семантика баз данных Хорна может быть охарактеризована тремя различными способами: (1) теория моделей, (2) теория фиксированных точек и (3) теория доказательств. И все эти три способа приводят к одной и той же семантике.  
  
Теория моделей имеет дело с набором моделей, которые отражают предполагаемое значение базы данных. Теория фиксированной точки имеет дело с оператором фиксированной точки, который создает совокупность всех атомов, которые могут быть выведены из базы данных как истинные. Теория доказательств имеет дело с процедурой, которая находит ответы на запросы относительно базы данных.  
Ван Эмден и Ковальски показали, что пересечение всех моделей DDB Хоара является своеобразной уникальной минимальной моделью. “Уникальная минимальная модель такая же, как и все атомы в фиксированной точке, являющиеся единственными атомами, доказываемыми теорией.” - писали они.  
  
А теперь перейдём к небольшому разбору и сравнению двух декларативных языков, используемых системами управления баз данных.  
  
Наиболее распространённым стандартным языком реляционных баз данных является SQL, разработанный в 1974 году фирмой IBM для экспериментальной реляционной системы управления базами данных System R.  
  
SQL включает в себя несколько формальных логических языков баз данных: DDL, VDL и DML, о которых было сказано выше.  
Также он поддерживает авторизацию доступа к объектам баз данных, которая осуществляется на основе специального набора операторов SQL. Суть доступа состоит в том, что для выполнения операторов SQL разного вида пользователь должен обладать различными полномочиями, в число которых входит полномочие на передачу всех или части полномочий другим пользователям, включая полномочие на передачу полномочий.  
  
Программа на SQL представляет собой линейную последовательность операторов. Так как это декларативный язык, то в стандарте языка нет операторов управления порядком выполнения запросов к базам данных.  
  
Выражения SQL могут выполняться либо интерактивно, либо встраиваться в исходный код программы, написанной на языке высокого уровня. Любое выражение встроенного SQL можно использовать как интерактивно, так и в прикладной программе. Именно поэтому в различных СУБД это может быть использовано вместе с другими языками программирования высокого уровня.  
  
На языке SQL существуют следующие основные операторы:  
1.	зарезервированные ключевые слова;  
2.	идентификаторы (имена) таблиц и столбцов таблиц;  
3.	логические, арифметические и строковые выражения, используемые для формирования критериев поиска информации в базе данных и для вычисления значений элементов результирующих таблиц;  
4.	идентификаторы (имен) операций и функций, используемых в выражениях.  
  
Все ключевые слова, имена функций, имена таблиц и столбцов записываются латинскими буквами. В языке SQL не делается различия между прописными и строчными буквами. Для конструирования имен таблиц и столбцов допустимо использовать буквы, цифры и знак “_”, но первым символом имени обязательно должна идти буква. Запрещено использование ключевых слов и имен функций в качестве идентификаторов таблиц и имен столбцов.  
  
Оператор, как правило, начинается с ключевого слова (SELECT – выбрать, CREATE - создать и т.д.) и заканчивается знаком «;».  
  
Операторы записываются в свободном формате и могут занимать несколько строк. Допустимыми разделителями лексических единиц в операторах SQL являются:  
1.	один или несколько пробелов;  
2.	один или несколько символов табуляции;  
3.	один или несколько символов новой строки.  
  
Далее, при описании синтаксиса операторов языка SQL используются следующие соглашения:  
1.	квадратные скобки не входят в число символов оператора и определяют необязательность элементов оператора, которые можно опустить при создании реального оператора;  
2.	знак «|» разделяет альтернативные варианты и определяет возможность выбора из двух или нескольких вариантов синтаксической конструкции, сам знак не включается в оператор;  
3.	прописными буквами записываются ключевые слова SQL;  
4.	в фигурных скобках записываются повторяющиеся элементы, а сами скобки не включаются в оператор;  
5.	в скобках <> записываются переменные нетерминальные символы, подлежащие замене в реальном операторе конструкцией из терминальных символов (идентификаторов, знаков операций, имен функций и т.п.), а сами символы <> не включаются в оператор.  
  
Итак, мы немного ознакомились с базовой конструкцией декларативного языка SQL. Теперь перейдём к Прологу.  
  
Декларативное представление программы Prolog состоит в том, что она представляет собой набор элементов данных.  
Действительно, полная программа называется базой данных, более отражая тот факт, что каждый объект в программе Prolog является данными. Факты, правила, головы правил, основы правил, цели (goals): все это на уровне синтаксиса просто структура. У нас есть диапазон слов, который позволяет нам различать контекст, в котором используются структуры: факт - это структура, используемая как утверждение; цель (goal) - это структура, используемая в качестве вопроса.   
Каждый факт и каждое правило в программе называется предикатом/предложением. Правило - это предложение, в котором есть голова и тело. Факт - это предложение в котором есть голова, но пустое тело.  
Программы на языке Prolog написаны в подмножестве логики первого порядка (FOL), логики предикатов. Язык Пролог включает в себя постоянные символы именования объектов и предикатные символы для именования отношений между объектами. По этой причине Пролог является подмножеством Datalog Databases.  
В Прологе как и предикат, так и константные символы записываются, начиная со строчного буквенного символа. Предикаты обычно записываются для логических языков с использованием круглых скобок, окружающих аргументы, следующие за предикатом, тем самым формируя атомарную формулу. С этим небольшим количеством обозначений мы уже можем изложить некоторую простую информацию в Прологе.   
Работать с реляционным представлением в Прологе достаточно удобно, так как такая модель прежде всего нацелены на человека - проста для понимания. Это позволяет 'делить' программу на компоненты (правила), реализация которых в общем случае не зависит друг от друга (в другом случае можно заменить ещё не написанные компоненты множеством фактов), тут же тестировать программу и быстрее находить ошибки в необходимом компоненте.  
При решении сложной задачи такое 'дробление' сильно помогает. Хотя и этого бывает недостаточно. Тогда трассировка спасает от потери в море информации. trace - главный помощник в понимании того, что вообще происходит при определённом запросе, как работают созданные правила и где найти ошибки.  
А теперь попробуем сравнить SQL и Пролог. Ведь они же должны чем-то отличаться?   
	Итак, следующие пункты относятся как к одному, так и к другому языку:  
1.  они оба управляемы логикой;  
2. они оба могут хранить, выражать и использовать отношения (логические отношения в Прологе);  
3. они оба могут хранить и выражать сложные логические условия;  
4. они оба имеют факты (данные в SQL) и могут получить выводы из этих фактов;  
5. они оба умеют исполнять запросы;  
и т.д  
	 
Да-да, они оба являются декларативными языками и языками баз данных, основанными на исчислении предикатов первого порядка.  

Но в чём же их отличия?  
Пролог и SQL основаны на логике первого порядка, но таблицы SQL - это простые бинарные отношения, тогда как предикаты Prolog - предложения, соответствующие Хорну.  
Бинарные отношения SQL - утверждения формы:  
  
`f(A, B, C, ... , N)`  
  
Где f - имя отношения, а A…N  - его переменные.  
	
А Бинарные отношения Пролога имеют следующую форму:  
  
	`A -> B, C, …, N`		
	
Где сами A … N - предложения Хорна.  
	
SQL-отношения - это эффективный способ описания данных. А соотношения на Прологе описывают сложные отношения между данными, которые сами хранятся как данные.  
  
Важно понимать, что в Прологе отсутствует разделение данных и операций. Факты, правила и запросы Пролога - это все предложения Хорна. Пролог не похож на C, с фактами вместо переменных и правилами вместо функций.  
Однако с другой стороны SQL очень похож на Prolog без правил или запросов.  
  
SQL-запросы также являются логическими предикатами, но SQL-запросы не хранятся в самой базе данных. Скорее, они используются для извлечения наборов данных из базы фактов. Но вполне можно хранить запрос в виде строки таблицы в базе данных SQL, но нельзя будет выполнить его именно в этой форме.  
  
Запросы Пролога хранятся в базе данных, как и любой другой его предикат, потому что они являются такими же по форме как и любой другой предикат Prolog.   
  
И вот что происходит: Prolog доказывает запрос путем опровержения: если он не может найти факт (или правило), который его докажет, он заявит, что цель верна, поскольку запрос всегда является ложным. При этом некоторые переменные связаны, поэтому могут создаваться наборы результатов, подобно тому, как SQL выполняет запросы SELECT.  
  
Современные системы управления базами данных SQL имеют такие функции, как хранимые процедуры и язык управления порядка происходящего. 
Prolog идёт с уже готовы с механизмом вывода, встроенным в его базу данных предложений Хорна, потому что это эффективный способ сделать вывод из баз данных фактов, заявленных как отношения.  
  
Особенность пролога, что всё является фактами, означает, что база данных, по сути, является программой. Поэтому каждый раз, когда в базу данных добавляется новый факт, вся программа должна быть перекомпилирована. Это огромный минус, который делает Prolog неэффективным для хранения больших наборов данных.   
Но у него нет причин, по которым он может быть неэффективен при извлечении данных. В данном случае Prolog будет использовать для этой цели те же алгоритмы, что используют и SQL. SQL, с другой стороны, хорошо подходит и для хранения, и поиска.  
  
Наконец, у Пролога есть несколько функций, которые SQL просто не имеет, а именно -  шаблонное совпадение, называемое унификацией, отрицание как failure и синтаксические элементы, которые облегчают обработку списка и обеспечивают обработку и анализ элементов естественного языка.  
Но и SQL тоже теперь имеет возможность рекурсивных запросов, которую он получил относительно недавно.
И, конечно, оба языка всё же слабы в вводе/выводе и математике. Хотя в прологе вполне легко совершить простейшие арифметические действия.  
  
С точки зрения языкового дизайна, SQL имеет тенденцию к своеобразным разрывам, с множеством различных языковых особенностей (предикаты, запросы, язык манипулирования данными, ...). А дизайн Пролога чрезвычайно последователен, так что весь язык на самом деле просто предикаты и несколько знаков препинания.  
  
Хотя они работают в одних и тех же концептуальных областях, их фокусы находятся в совершенно разных направлениях.   
В терминах Пролога SQL - это, прежде всего, механизм Фактов и Отношений, тогда как Prolog - это в основном механизм правил и выводов. Каждый из них может сделать что-либо в своей ограниченной степени, и даже небольшое увеличение сложности приводит к видимым трудностям. 
И да, в Прологе можно хранить данные (факты), но он вовсе не предназначено для "хранения, поиска, проецирования и сокращения триллионов строк с тысячами одновременных пользователей", для чего SQL был сделан.  
  
Конечно, несмотря на всю их привлекательность, классические реляционные системы управления базами данных являются ограниченными. Они идеально походят для таких традиционных приложений, как системы резервирования билетов в театр или мест в гостиницах, а также для банковских систем, но их применение в системах автоматизации, интеллектуальных системах обучения и других системах, основанных на большом количестве данных, часто является затруднительным.   
Это прежде всего связано с примитивностью структур данных, лежащих в основе реляционной модели. Плоские нормализованные отношения универсальны и теоретически достаточны для представления данных любой предметной области. Однако в реальных ситуация в базе данных могут появиться сотни, а может даже и тысячи таблиц, над которыми будут постоянно выполняются дорогостоящие операции, необходимые для воссоздания сложных структур данных, присущих концептуальной области.  
  
Другим серьезным ограничением реляционных систем являются их относительно слабые возможности по части представления семантики приложения. Хоть и в Прологе есть необходимая грамматика для анализа элементов естественного языка, она далеко не идеальна.
Самое большое, что обеспечивают реляционные системы управления базами данных - это возможность формулирования и поддержки ограничений целостности данных.  

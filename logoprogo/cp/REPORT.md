# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Иванопуло А.Б.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Опишите, какие знания и навыки вы получите в результате выполнения курсового проекта

## Задание
 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM;  
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующие предикаты: `parent(родитель, ребенок)`, `sex(человек, m/f)`;  
 3. Реализовать предикат проверки/поиска свекрови (mother-in-law);  
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве;  
 5. Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы.  
## Получение родословного дерева
В данной работе используется родословное дерево of William Shakespeare. Изначально в нём было 23 человека, но я добавила в него ещё 16. 
Итого, в дереве [William Shakespeare Tree](shakespearever2.ged) 39 индивидуумов - 6 поколений.
## Конвертация родословного дерева
Для преобразования файла формата GEDCOM в набор утверждений на Прологе я решила использовать Python. На это было две причины.
Во-первых, он позволяет легко проводить обработку текста. Во-вторых, я с ним немного знакома (очень немного: только файлы из папки переименовывать умею, ведь если названия однотипные и файлов много, то по одному, "руками" делать это долго и скучно).  

Итак, читаем мы из `"shakespearver2.ged"`, пишем в `"pred.pl"`.  
```python
with open("shakespearever2.ged", "r") as rf:
	with open("pred.pl", "w") as wf:
```
В конце программы закроем оба файла.
```python
wf.close() 
rf.close() 
```
Так как в GEDCOM каждому человеку сопоставлен свой ID, то при первом прохождении и преобразовании в предикаты вида `sex(человек, m/f)` будет необходимо создать словарь из имён.  
Такое представление будет удобнее потому!, что в словарях информация представлена не как последовательность, а как набор пар. Наш словарь - 
```python
ID = {}
```
Идём построчно по файлу. Если попадается такое, что в строке до четвёртого символа попадается '0 @I', то PID (person ID) становится равным куску строки от 2 до 9 эл (9 не включается).  
Если line[2:6] (со 2й по 6ую) == 'GIVN', то givn (given name) = оставшейся части строки без пробелов в конце.  
Если попадается в заданных рамках 'SURN', surn (surname) = оставшейся части строки без пробелов в конце; name = surn, пробел и givn, а в словарь `ID` добавляется name с ключом PID.  
Если 'SEX', то sex = 6-ому символу, но не заглавной букве, а строчной. Тогда и можно определить предикат `sex(name, sex)` и распечатать его в `pred.pl`.  
```python
for line in rf:
			if line[:4] == '0 @I':
				PID = line[2:9]
			elif line[2:6] == 'GIVN':
				givn = line[7:].rstrip()
			elif line[2:6] == 'SURN':
				surn = line[7:].rstrip()
				name = '\'' + surn + ' ' + givn + '\''
				ID[PID] = name
			elif line[2:5] == 'SEX':
				sex = line[6].lower()
				predicate = 'sex(' + name + ', ' + sex + ').\n'
				wf.write(predicate)
```
А теперь начинаем всё с начала. Но словарь `ID` уже не пустой.  
В файле GEDCOM ID есть не только у людей, но и ещё и у семей. И в семьях хранится информация об IDs родителей и ребёнка, поэтому начнём с поиска ID семей.  
Если в заданных рамках попадается '0 @F', то husb (husband) = ' ', wife = ' '. Они пока пустые, но необходимо их обозначить, чтобы искать их дальше.  
Если 'HUSB', то HID (husband ID) = оставшейся строчке без пробелов в конце, а husb = name из словаря с ключом HID.  
Если 'WIFE', то WID (wife ID) = оставшейся строчке без пробелов в конце, а wife = name из словаря с ключом WID.  
Если 'CHIL', то CID (child ID) = оставшейся строчке без пробелов в конце, а child = name из словаря с ключом CID.  
Можно записывать предикаты: `parent(husb, child)`, `parent(wife, child)`, и печатать их в `pred.pl`.  

```python
		rf.seek(0)
		for line in rf:
			if line[:4] == '0 @F':
				husb = ' '; wife = ' '
			elif line[2:6] == 'HUSB':
				HID = line[7:].rstrip()
				husb = ID.get(HID)
			elif line[2:6] == 'WIFE':
				WID = line[7:].rstrip()
				wife = ID.get(WID)
			elif line[2:6] == 'CHIL':
				CID = line[7:].rstrip()
				child = ID.get(CID)
				predicate1 = 'parent(' + husb + ', ' + child + ').\n'
				predicate2 = 'parent(' + wife + ', ' + child + ').\n'
				wf.write(predicate1)
				wf.write(predicate2)
 ```
Стоит обратить внимание на то, что в данном дереве и всех людей либо 2 родителя, либо их вообще нет. Поэтому ситуация с одним родителем не рассматривается.
Также в дереве есть "исключение" из позже поставленных правил родства: 'Barnard John' и 'Nash Thomas' - мужья 'Shakespeare Susanna', но ни от одного, ни от другого детей нет. Предикат вида `married(X, Y)` будет обозначен для этих людей в самой программе на Прологе как предикаты-факты.  

Весь код парсера: [Parser](parser.py)
## Предикат поиска родственника

Опишите, как устроен предикат поиска родственника, приведите его исходный код и примеры запросов/ответов (протокол работы).

## Определение степени родства

Приведите описание метода решения, важные фрагменты исходного кода, протокол работы.

## Естественно-языковый интерфейс

## Выводы

Сформулируйте *содержательные* выводы по курсовому проекту в целом. Чему он вас научила? 
Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки.

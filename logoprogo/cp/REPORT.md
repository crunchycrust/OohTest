# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Савина А.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Опишите, какие знания и навыки вы получите в результате выполнения курсового проекта

## Задание
 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM;  
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующие предикаты: `parent(родитель, ребенок)`, `sex(человек, m/f)`;  
 3. Реализовать предикат проверки/поиска свекрови (mother-in-law);  
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве;  
 5. Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы.  
## Получение родословного дерева
В данной работе используется родословное дерево of William Shakespeare. Изначально в нём было 23 человека, но я добавила в него ещё 16. 
Итого, в дереве [William Shakespeare Tree](shakespearever2.ged) 39 индивидуумов - 6 поколений.
## Конвертация родословного дерева
Для преобразования файла формата GEDCOM в набор утверждений на Прологе я решила использовать Python. На это было две причины.
Во-первых, он позволяет легко проводить обработку текста. Во-вторых, я с ним немного знакома (очень немного: только файлы из папки переименовывать умею. Ведь если названия однотипные и файлов много, то по одному, "руками" делать это долго и скучно).  

Итак, читаем мы из `"shakespearver2.ged"`, пишем в `"pred.pl"`.  
```python
with open("shakespearever2.ged", "r") as rf:
	with open("pred.pl", "w") as wf:
```
В конце программы закроем оба файла, конечно.
```python
wf.close() 
rf.close() 
```
Так как в GEDCOM каждому человеку сопоставлен свой ID, то при первом прохождении и преобразовании в предикаты вида `sex(человек, m/f)` будет необходимо создать словарь из имён.  
Такое представление будет удобнее потому, что в словарях информация представлена не как последовательность, а как набор пар. Наш словарь : 
```python
ID = {}
```
Идём построчно по файлу. Если попадается такое, что в строке до четвёртого символа попадается '0 @I', то  
PID (person ID) становится равным куску строки от 2 до 9 эл (9 не включается). Например, `@I0001@`.
Если line[2:6] (со 2й по 6ую) == 'GIVN', то givn (given name) = оставшейся части строки без пробелов в конце.  
Если попадается в заданных рамках 'SURN', surn (surname) = оставшейся части строки без пробелов в конце; name = surn, пробел и givn, а в словарь `ID` добавляется name с ключом PID.  
Если 'SEX', то sex = 6-ому символу, но не заглавной букве, а строчной. Тогда и можно определить предикат   
`sex(name, sex)` и распечатать его в `pred.pl`.  
```python
		for line in rf:
			if line[:4] == '0 @I':
				PID = line[2:9]
			elif line[2:6] == 'GIVN':
				givn = line[7:].rstrip()
			elif line[2:6] == 'SURN':
				surn = line[7:].rstrip()
				name = '\'' + surn + ' ' + givn + '\''
				ID[PID] = name
			elif line[2:5] == 'SEX':
				sex = line[6].lower()
				predicate = 'sex(' + name + ', ' + sex + ').\n'
				wf.write(predicate)
```
А теперь начинаем всё с начала. Но словарь `ID` уже не пустой.  
В файле GEDCOM ID есть не только у людей, но и ещё и у семей. И в семьях хранится информация об IDs родителей и ребёнка, поэтому начнём с поиска ID семей.  
Если в заданных рамках попадается '0 @F', то husb (husband) = ' ', wife = ' '. Они пока пустые, но необходимо их обозначить, чтобы искать дальше.  
Если 'HUSB', то HID (husband ID) = оставшейся строчке без пробелов в конце, а husb = name из словаря с ключом HID.  
Если 'WIFE', то WID (wife ID) = оставшейся строчке без пробелов в конце, а wife = name из словаря с ключом WID.  
Если 'CHIL', то CID (child ID) = оставшейся строчке без пробелов в конце, а child = name из словаря с ключом CID.  
Можно записывать предикаты: `parent(husb, child)`, `parent(wife, child)`, и печатать их в `pred.pl`.  

```python
		rf.seek(0)
		for line in rf:
			if line[:4] == '0 @F':
				husb = ' '; wife = ' '
			elif line[2:6] == 'HUSB':
				HID = line[7:].rstrip()
				husb = ID.get(HID)
			elif line[2:6] == 'WIFE':
				WID = line[7:].rstrip()
				wife = ID.get(WID)
			elif line[2:6] == 'CHIL':
				CID = line[7:].rstrip()
				child = ID.get(CID)
				predicate1 = 'parent(' + husb + ', ' + child + ').\n'
				predicate2 = 'parent(' + wife + ', ' + child + ').\n'
				wf.write(predicate1)
				wf.write(predicate2)
 ```
Стоит обратить внимание на то, что в данном дереве у всех людей либо 2 родителя, либо их вообще нет. Поэтому ситуация с одним родителем не рассматривается.  
Также в дереве есть "исключение" из позже поставленных правил родства: 'Barnard John' и 'Nash Thomas' - мужья 'Shakespeare Susanna', но ни от одного, ни от другого детей нет. Предикат вида `married(X, Y)` будет обозначен для этих людей в самой программе на Прологе предикатами-фактами.  

Весь код парсера:  [Parser](parser.py)
## Предикат поиска родственника
Задание: реализовать предикат проверки/поиска свекрови (mother-in-law).  

Основной предикат `minlaw(X, Y)` работает следующим образом:   
Если Y женат/замужем на/за каким-нибудь Z и если X - это мать Z, то X - свекровь Y.  
```prolog
minlaw(X, Y) :- married(Z, Y), mother(X, Z).
```
* Предикат `married(X, Y)` отвечает за проверку/поиск партнёра X для Y.  
Так как почти у всех пар есть дети, то проверку на брак можно осуществлять, опираясь на это.  
Итак, если у Y имеется какой-нибудь ребёнок, и у этого ребёнка есть ещё один родитель X, который не равен Y, то X будет парой Y.  
Такой способ работает только если в семье один ребёнок. Если же их несколько, то имя свекрови будет выведено n (количество детей) раз.  
Поэтому воспользуемся отсечением. Выражение `married` будет верным только тогда, когда части по обе стороны от cut верны.  
Раньше, когда мы доходили до ситуации `'Hathaway Anna' \= 'Hathaway Anna'`, то просто начинали искать нового ребёнка (возвращались к `child(Z, Y)`). Но теперь если условия до cut верны, а после - не соблюдены, то мы сразу получаем `fail.`  

Как было раньше отмечено, ситуация "`'Barnard John' и 'Nash Thomas' - мужья 'Shakespeare Susanna'`" - своеобразное исключение. Поэтому для неё написаны соответствующие предикаты-факты.
```prolog
child(X, Y) :- parent(Y, X).

married(X, Y) :- child(Z, Y), !, child(Z, X), X \= Y.
married('Shakespeare Elizabeth', 'Nash Thomas').
married('Nash Thomas', 'Shakespeare Elizabeth').
married('Shakespeare Elizabeth', 'Barnard John').
married('Barnard John', 'Shakespeare Elizabeth').
```
Стоит заметить, что здесь также используется предикат `child(X, Y)`. Смысла в нём нет. Это всего лишь "обратный" предикат `parent`, который здесь можно было использовать. Просто с child легче понимать, что происходит.  

* Предикат `mother(X, Y)` проверяет/ищеть мать X для Y.  
Тут всё просто. Если есть такой X женского пола, что X - родитель Y, то X - мать Y.  
```prolog
mother(X, Y) :- sex(X, f), parent(X, Y).
```
Примеры запросов:
```prolog
?- minlaw(X, 'Hathaway Anne').
X = 'Arden Mary' ;
false.

?- minlaw(X, 'Shakespeare William').
X = 'Hathaway Joan' ;
false.

?- minlaw(X, 'Hart Thomas').
false.

?- minlaw(X, 'Nash Thomas').
X = 'Shakespeare Susanna' ;
false.
```
Были также осуществлён предикат поиска father-in-law `finlaw(X, Y)`. Работает он по такому же принципу.  
```prolog
father(X, Y) :- sex(X, m), parent(X, Y).

finlaw(X, Y) :- married(Z, Y), father(X, Z).
```

Примеры запросов:
```prolog
?- finlaw(X, 'Hathaway Anne').
X = 'Shakespeare John' ;
false.

?- finlaw(X, 'Shakespeare William').
X = 'Hathaway Richard' ;
false.

?- finlaw(X, 'Shakespeare Edmund').
false.

?- finlaw(X, 'Barnard John').
X = 'Hall John' ;
false.
```
## Определение степени родства

Приведите описание метода решения, важные фрагменты исходного кода, протокол работы.

## Естественно-языковый интерфейс

## Выводы

Сформулируйте *содержательные* выводы по курсовому проекту в целом. Чему он вас научила? 
Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки.

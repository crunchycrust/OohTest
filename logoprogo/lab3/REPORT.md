#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Савина А. А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Пространство состояний - это совокупность ситуаций, встречающихся в задаче, достижимых из начального состояния, при помощи определённых правил. Часто пространство состояний бывает представлено в виде графа, вершины которого соответствуют ситуациям-состояниям. В таком случае решение задачи сводится к поиску пути в графе. Используя его, мы строим дерево решений, вершина которого - исходная ситуация, а конечная - одна из многочисленных "детей".  

Задачи, решаемые c помощью пространства состояний, обычно направлены на нахождение кратчайшего пути из одного состояния в другое, но они также погут сводиться всего лишь к нахождению хотя бы одного решения.  

В дискретной математике и зачастую в программировании граф-пространство состояний представлен с помощью матрицы смежности. Но такое представление не удобно для работы в Прологе и может привести к зацикливанию. Поэтому для описания пространства состояний обычно используется предикат вида (A, B), где B, находимый при помощи определённого правила, является "преемником" вершины A.  

Для относительно простых задач, желательно с конечным количеством возможных состояний, Пролог хорошо подходит. А ещё он позволяет легко тестировать программу и быстрее находить ошибки в необходимом компоненте. Если же в задаче очень большое количество условий и различные способы поиска не приводят к значительному сокращению переходных ситуаций, то Пролог, возможно, не является лучшим выбором.  

## Задание

4. "Расстановка мебели". Площадь разделена на шесть квадратов, пять из них заняты мебелью, шестой - свободен. Переставить мебель так, чтобы шкаф и кресло поменялись местами, при этом никакие два предмета не могут стоять на одном квадрате.
## Принцип решения
Существует 3 основых предиката:  `roomDF(Initial, Final)` для поиска в глубину, `roomBF(Initial, Final)` для поиска в ширину, `roomI(Initial, Final)` для поиска в глубину с итеративным погружением.  
Начальное `Initial` и конечное `Final` состояния подаются в виде списков.  
Например, `roomBF(["t", "c", "ac", "t", "_", "w"], ["t", "c", "w", "t", "_", "ac"]).`  

Задаваемые правилами переходы от одного состояния к другому описаны предикатом move(A, B), где B – состояние A после применения к нему определённых из правил.  
Так как в задаче 6 квадратов и 5 различных вещей (включая пустоту), то будет нецелесообразно описывать правила для каждой из них. Достаточно описать правила для пустоты и какого-нибудь X.  

Итого, имеем 2 основых правила перехода:  
1) Если пустота стоит рядом с каким-либо предметом:
```prolog
move(A,B) :-
	append(E, ["_", X|Tail], A),
	append(E, [X, "_"|Tail], B).

move(A,B) :-
	append(E, [X, "_"|Tail], A),
	append(E, ["_", X|Tail], B).
```
2) Перемещение предмета из 1й клетки в 4ую, из 2й в 5ую, из 3й в 6ую и обратно:
```prolog
move(A, B) :-
	append(E, [X, F1, F2, "_"|T], A),
	append(E, ["_", F1, F2, X|T], B).

move(A, B) :-
	append(E, ["_", F1, F2, X|T], A),
	append(E, [X, F1, F2, "_"|T], B).

``` 
Для предотвращения зацикливания используется предикат `findchildren([Now|T], [Child, Now|T])`, в который подаётся список с последовательностью переходов `[Now|T]`. А возвращает этот предикат `[Child, Now|T]`- обновлённую последовательность, первый элемент `Child` которой является последним состоянием.  
С помощью предиката `move(Now, Child)` находим одного из возможных детей. Затем, используя `not(member(Child, [Now|T]))`, проверяем существующий список на наличие найденного "ребёнка".
```prolog
findchildren([Now|T], [Child, Now|T]) :-
    	move(Now, Child),
    	not(member(Child,[Now|T])).
```

Так как `findchildren([Now|T], [Child, Now|T])` возвращет продлённый список состояний в обратном порядке, то необходимо выводить его элементы наоборот. `reverse(Res, Ref)` - стандартный предикат, возращающий "перевёрнутый" список `Ref`. 
  
Для печати списка используется предикат `writeo([H|T])`.  
```prolog
writeo([]).
writeo([H|T]) :-  write(H), nl, writeo(T).
```
Для хронометрирования процесса применяется стандартный предикат `get_time(X)` до начала работы основного предиката, а потом после завершения. Разница между вторым и первым - и есть время, потраченное на выполнение поиска.  
  
  
* Предикат `roomDF(Initial, Final)` для поиска в глубину.  
Поиск в глубину обычно исследует сначала самую "левую" ветвь дерева, а когда процесс заходит в тупик, то он снова начинает из корня и идёт вниз по другому пути. Это простейший метод поиска, но у него есть два главных недостатка:  
1) если пространство состояний не является конечным, то мы можем застрять в бесконечной ветви;  
2) если же оно конечно, то первое найденное решение может быть не самым коротким.
```prolog
roomDF(Initial, Final) :-
	nl, write('Depth-first search'), nl, nl, 
    	get_time(T1),
	df([Initial], Final, Res),
	reverse(Res, Ref),
	writeo(Ref),
	get_time(T2), nl, 
	T is T2 - T1,
	write('TIME: '), write(T), nl, nl.
```
`df([Initial], Final, Res)` - предикат, осуществляющий сам поиск. `Now` - аргумент, в котором хранится растущая последовательность переходов. `Goal` - последовательность, являющаяся конечным сотоянием (оно не изменяется в течении процесса и необходимо только для остановки процесса наращивания вариантов). `Res` -  переменная, в которую пойдёт конечный результат.  
Сначала ищем следующее состояние при помощи `findchildren(Now, X)`. `X` становится обновлённым списком пройденных состояний. Далее используем рекурсию и вызываем `df(X, Goal, Res)`. Если первый элемент становится равным `Goal`, то `Res` превращается в `[Goal|T]`, и процесс завершается.  
```prolog
df([Goal|T], Goal, [Goal|T]).
df(Now, Goal, Res) :-
	findchildren(Now, X),
	df(X, Goal, Res).
```

* Предикат `roomBF(Initial, Final)` для поиска в ширину.  
Поиск в ширину предусматривает в первую очередь переход к вершинам, ближайшим к корню, затем к их детям и т.д. То есть рассматривает всех детей корня слева направо, а потом переходит к их детям, отбрасывая тех, которые являются тупиками.  
Поиск в ширину подходит для тех задач, где ветви дерева состояний не имеют одинаковой длины, и он гарантирует нахождение кратчайшего пути. Однако при его использовании память может закончится очень быстро.  
```prolog
roomBF(Initial, Final) :-
    	nl, write('Breadth-first search'), nl, nl,
    	get_time(T1),
    	bf([[Initial]], Final, Res),
	reverse(Res, Ref),	
    	writeo(Ref),
    	get_time(T2), nl,
    	T is T2 - T1,
    	write('TIME: '), write(T), nl, nl.
```
`bf([Now|BeforeNow], Goal, Res)` - предикат, осуществляющий сам поиск. `[Now|BeforeNow]` - аргумент, в котором хранятся все возможные растущая последовательности переходов. `Goal` - последовательность, являющаяся конечным сотоянием (оно не изменяется в течении процесса и необходимо только для остановки процесса наращивания вариантов). `Res` -  переменная, в которую пойдёт конечный результат.  
Сначала  с помощью стандартного предиката `findall(X, findchildren(Now, X), Children)` находим всех детей последнего узла в списке, и складываем их в список списков возможных детей `Children`. Соединяем существующий список решений `BeforeNow` с детьми `Children` - `CBN`, вызываем `bf(CBN, Goal, Res)`. Если первый список решений будет иметь Goal as a head, то `Res` превращается в `[Goal|T]`, и процесс завершается.  
```prolog
bf([[Goal|T]|_], Goal, [Goal|T]).
bf([Now|BeforeNow], Goal, Res):-
    	findall(X, findchildren(Now, X), Children),
    	append(BeforeNow, Children, CBN),
    	bf(CBN, Goal, Res).
```

* Предикат `roomI(Initial, Final)` в глубину с итеративным погружением.
Итеративное углубление/погружение - разновидность поиска в глубину. Это ограниченный поиск, в котором постепенно увеличивается граница погружения. 
Для такого ограничения необходима переменная `Bound`, которая с каждым тупиковым вариантом увеличивается на один. Решение найдено, если конечное сотсояние соответствует достигнутому (в данной задаче используется этот способ), или `Bound` становится равно заранее поставленному числу.
Это оптимальный поиск для нахождения кратчайшего решения, если у дерева есть конечная глубина.
```prolog
roomI(Initial, Final) :-
	nl, write('Iterative deepening search'), nl, nl,
	get_time(T1),
	expbound(Bound, 1),
	id([Initial], Final, Res, Bound),
	reverse(Res, Ref),
	writeo(Ref),
	get_time(T2), nl,
	T is T2 - T1,
	write('TIME: '), write(T), nl, nl.
```
`id(Now, Goal, Res, Bound)` - предикат, осуществляющий сам поиск. `Now` - аргумент, в котором хранится растущая последовательность переходов. `Goal` - последовательность, являющаяся конечным сотоянием (оно не изменяется в течении процесса и необходимо только для остановки процесса наращивания вариантов). `Res` -  переменная, в которую пойдёт конечный результат. `Bound` - граница.  
Для её увеличения используется предикат `expbound(B, X)`.  
```prolog
expbound(X, X).
expbound(B, X):-
	X1 is X + 1,
	expbound(B, X1).
```
Сначала проверяем `Bound` на существование. Ищем следующее состояние при помощи `findchildren(Now, Next)`. `Next` становится обновлённым списком пройденных состояний. Уменьшаем `Bound` на один и снова вызываем `id(Next, Goal, Res, NBound)`, но уже с новым ограничителем. Если первый элемент становится равным `Goal`, то `Res` превращается в `[Goal|T]`, и процесс завершается.  
```prolog
id([Goal|T], Goal, [Goal|T], _).
id(Now, Goal, Res, Bound):- 
	Bound > 0,
	findchildren(Now, Next),
	NBound is Bound-1,
	id(Next, Goal, Res, NBound).
```
## Результаты
Выполнение задания:

```prolog
?- roomDF(["t", "c", "ac", "t", "_", "w"], ["t", "c", "w", "t", "_", "ac"]).

Depth-first search

[t,c,ac,t,_,w]
[t,c,ac,t,w,_]
[t,c,_,t,w,ac]
[t,c,t,_,w,ac]
[t,c,t,w,_,ac]
[t,c,t,w,ac,_]
[t,c,_,w,ac,t]
[t,c,w,_,ac,t]
[t,c,w,ac,_,t]
[t,c,w,ac,t,_]
[t,c,_,ac,t,w]
[t,c,ac,_,t,w]
[_,c,ac,t,t,w]
[c,_,ac,t,t,w]
[c,ac,_,t,t,w]
[c,ac,t,_,t,w]
[c,ac,t,t,_,w]
[c,ac,t,t,w,_]
[c,ac,_,t,w,t]
[c,ac,t,_,w,t]
[c,ac,t,w,_,t]
[c,ac,t,w,t,_]
[c,ac,_,w,t,t]
[c,ac,w,_,t,t]
[c,ac,w,t,_,t]
[c,_,w,t,ac,t]
[c,w,_,t,ac,t]
[c,w,t,_,ac,t]
[c,w,t,ac,_,t]
[c,w,t,ac,t,_]
[c,w,_,ac,t,t]
[c,w,ac,_,t,t]
[c,w,ac,t,_,t]
[c,w,ac,t,t,_]
[c,w,_,t,t,ac]
[c,w,t,_,t,ac]
[c,w,t,t,_,ac]
[c,_,t,t,w,ac]
[c,t,_,t,w,ac]
[c,t,t,_,w,ac]
[c,t,t,w,_,ac]
[c,t,t,w,ac,_]
[c,t,_,w,ac,t]
[c,t,w,_,ac,t]
[c,t,w,ac,_,t]
[c,t,w,ac,t,_]
[c,t,_,ac,t,w]
[c,t,ac,_,t,w]
[_,t,ac,c,t,w]
[t,_,ac,c,t,w]
[t,ac,_,c,t,w]
[t,ac,c,_,t,w]
[t,ac,c,t,_,w]
[t,ac,c,t,w,_]
[t,ac,_,t,w,c]
[t,ac,t,_,w,c]
[t,ac,t,w,_,c]
[t,ac,t,w,c,_]
[t,ac,_,w,c,t]
[t,ac,w,_,c,t]
[t,ac,w,c,_,t]
[t,_,w,c,ac,t]
[t,w,_,c,ac,t]
[t,w,c,_,ac,t]
[t,w,c,ac,_,t]
[t,w,c,ac,t,_]
[t,w,_,ac,t,c]
[t,w,ac,_,t,c]
[t,w,ac,t,_,c]
[t,w,ac,t,c,_]
[t,w,_,t,c,ac]
[t,w,t,_,c,ac]
[t,w,t,c,_,ac]
[t,_,t,c,w,ac]
[t,t,_,c,w,ac]
[t,t,c,_,w,ac]
[t,t,c,w,_,ac]
[t,t,c,w,ac,_]
[t,t,_,w,ac,c]
[t,t,w,_,ac,c]
[t,t,w,ac,_,c]
[t,t,w,ac,c,_]
[t,t,_,ac,c,w]
[t,t,ac,_,c,w]
[_,t,ac,t,c,w]
[t,_,ac,t,c,w]
[t,ac,_,t,c,w]
[t,ac,t,_,c,w]
[t,ac,t,c,_,w]
[t,ac,t,c,w,_]
[t,ac,_,c,w,t]
[t,ac,c,_,w,t]
[t,ac,c,w,_,t]
[t,ac,c,w,t,_]
[t,ac,_,w,t,c]
[t,ac,w,_,t,c]
[t,ac,w,t,_,c]
[t,_,w,t,ac,c]
[t,w,_,t,ac,c]
[t,w,t,_,ac,c]
[t,w,t,ac,_,c]
[t,w,t,ac,c,_]
[t,w,_,ac,c,t]
[t,w,ac,_,c,t]
[t,w,ac,c,_,t]
[t,w,ac,c,t,_]
[t,w,_,c,t,ac]
[t,w,c,_,t,ac]
[_,w,c,t,t,ac]
[w,_,c,t,t,ac]
[w,c,_,t,t,ac]
[w,c,t,_,t,ac]
[w,c,t,t,_,ac]
[w,c,t,t,ac,_]
[w,c,_,t,ac,t]
[w,c,t,_,ac,t]
[w,c,t,ac,_,t]
[w,c,t,ac,t,_]
[w,c,_,ac,t,t]
[w,c,ac,_,t,t]
[w,c,ac,t,_,t]
[w,_,ac,t,c,t]
[w,ac,_,t,c,t]
[w,ac,t,_,c,t]
[w,ac,t,c,_,t]
[w,ac,t,c,t,_]
[w,ac,_,c,t,t]
[w,ac,c,_,t,t]
[w,ac,c,t,_,t]
[w,ac,c,t,t,_]
[w,ac,_,t,t,c]
[w,ac,t,_,t,c]
[w,ac,t,t,_,c]
[w,_,t,t,ac,c]
[w,t,_,t,ac,c]
[w,t,t,_,ac,c]
[w,t,t,ac,_,c]
[w,t,t,ac,c,_]
[w,t,_,ac,c,t]
[w,t,ac,_,c,t]
[w,t,ac,c,_,t]
[w,t,ac,c,t,_]
[w,t,_,c,t,ac]
[w,t,c,_,t,ac]
[_,t,c,w,t,ac]
[t,_,c,w,t,ac]
[t,c,_,w,t,ac]
[t,c,w,_,t,ac]
[t,c,w,t,_,ac]

TIME: 0.9137101173400879

true .

?- roomBF(["t", "c", "ac", "t", "_", "w"], ["t", "c", "w", "t", "_", "ac"]).

Breadth-first search

[t,c,ac,t,_,w]
[t,c,ac,t,w,_]
[t,c,_,t,w,ac]
[t,c,t,_,w,ac]
[t,c,t,w,_,ac]
[t,_,t,w,c,ac]
[t,t,_,w,c,ac]
[t,t,w,_,c,ac]
[_,t,w,t,c,ac]
[t,_,w,t,c,ac]
[t,c,w,t,_,ac]

TIME: 0.13980793952941895

true .

?- roomI(["t", "c", "ac", "t", "_", "w"], ["t", "c", "w", "t", "_", "ac"]).

Iterative deepening search

[t,c,ac,t,_,w]
[t,c,ac,t,w,_]
[t,c,_,t,w,ac]
[t,c,t,_,w,ac]
[t,c,t,w,_,ac]
[t,_,t,w,c,ac]
[t,t,_,w,c,ac]
[t,t,w,_,c,ac]
[_,t,w,t,c,ac]
[t,_,w,t,c,ac]
[t,c,w,t,_,ac]

TIME: 0.08476686477661133

true .
```

Другие тесты:
```prolog
?- roomI(["t", "c", "_", "w"], ["t", "c", "w", "_"]).

Iterative deepening search

[t,c,_,w]
[t,c,w,_]

TIME: 0.013580799102783203

true .

?- roomBF(["t", "c", "ac", "t", "_", "w"], ["t", "c", "ac", "t", "_", "w"]).

Breadth-first search

[t,c,ac,t,_,w]

TIME: 0.008810043334960938

true .

?- roomDF([], []).

Depth-first search

[]

TIME: 0.005964040756225586

true .
```

## Выводы

Сформулируйте *содержательные* выводы по лабораторной работе. 
Чему она вас научила? Над чем заставила задуматься? 

Какие алгоритмы поиска в каких случаях удобно использовать? Какие оказались оптимальными в вашем конкретном случае?

Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную.





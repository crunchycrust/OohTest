#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Савина А. А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Пространство состояний - это совокупность ситуаций, встречающихся в задаче, достижимых изначального состояния, при помощи определённых правил. Часто пространство состояний бывает представлено в виде графа, вершины которого соответствуют ситуациям-состояниям. В таком случае решение задачи сводится к поиску пути в графе. Используя его, мы строим дерево решений, вершина которого - исходная ситуация, а конечная - одна из многочисленных "детей".  

Задачи, решаемые c помощью пространства состояний, обычно направлены на нахождение кратчайшего пути из одного состояния в другое, но они также погут сводиться всего лишь к нахождению хотя бы одного решения.  

В дискретной математике и зачастую в программировании граф-пространство состояний представлен с помощью матрицы смежности. Но такое представление не удобно для работы в Прологе и может привести к зацикливанию. Поэтому для описания пространства состояний обычно используется предикат вида (A, B), где B, находимый при помощи определённого правила, является "преемником" вершины A.  

Для относительно простых задач, желательно для конечного количества возможных состояний Пролог хорошо подходит. А ещё он позволяет легко тестировать программу и быстрее находить ошибки в необходимом компоненте. Если же в задаче очень большое количество условий и различные способы поиска не приводят к значительному сокращению переходных ситуаций, то Пролог, возможно, не является лучшим выбором.  

## Задание

4. "Расстановка мебели". Площадь разделена на шесть квадратов, пять из них заняты мебелью, шестой - свободен. Переставить мебель так, чтобы шкаф и кресло поменялись местами, при этом никакие два предмета не могут стоять на одном квадрате.
## Принцип решения
Существует 3 основых предиката:  `roomDF(Initial, Final)` для поиска в глубину, `roomBF(Initial, Final)` для поиска в ширину, `roomI(Initial, Final)` для поиска в глубину с итеративным погружением.  
Начальное `Initial` и конечное `Final` состояния подаются в виде списков.  
Например, `roomBF(["t", "c", "ac", "t", "_", "w"], ["t", "c", "w", "t", "_", "ac"]).`  

Задаваемые правилами переходы от одного состояния к другому описаны предикатом move(A, B), где B – состояние A после применения к нему одного из правил.  
Так как в задаче 6 квадратов и 5 различных вещей (включая пустоту), то будет не?целесообразно описывать правила для каждой из них. Достаточно описать правила для пустоты и какого-нибудь X, стоящего в определённом месте относительно пустоты.  

Итого, имеем 3 основых правил перехода:  
1) Если пустота стоит рядом с каким-либо предметом:
```prolog
move(A,B):-
	append(End, ["_", X|Tail], A),
	append(End, [X, "_"|Tail], B).

move(A,B):-
	append(End, [X, "_"|Tail], A),
	append(End, ["_", X|Tail], B).
```
2) Если пустота и предмет находятся в разных конца списка, то это не значит, что они не могут поменяться местами, так как мы имеем дело с комнатой:
```prolog
move(A, B) :-
	append(End, [X, F1, F2, F3, F4, "_"|T], A),
	append(End, ["_", F1, F2, F3, F4, X|T], B).

move(A, B) :-
	append(End, ["_", F1, F2, F3, F4, X|T], A),
	append(End, [X, F1, F2, F3, F4, "_"|T], B).
```
3) Перемещение предмета из второй клетки в пятую и обратно:
```prolog
move(A, B) :-
	append(End, [X, F1, F2, "_"|T], A),
	append(End, ["_", F1, F2, X|T], B).

move(A, B) :-
	append(End, ["_", F1, F2, X|T], A),
	append(End, [X, F1, F2, "_"|T], B).

``` 

Для предотвращения зацикливания используется предикат `findchildren([Now|T], [Child, Now|T])`.

## Результаты
Выполнение задания:

```prolog
?- roomDF(["t", "c", "ac", "t", "_", "w"], ["t", "c", "w", "t", "_", "ac"]).

Depth-first search

[t,c,ac,t,_,w]
[t,c,ac,t,w,_]
[_,c,ac,t,w,t]
[c,_,ac,t,w,t]
[c,ac,_,t,w,t]
[c,ac,t,_,w,t]
[c,ac,t,w,_,t]
[c,ac,t,w,t,_]
[_,ac,t,w,t,c]
[ac,_,t,w,t,c]
[ac,t,_,w,t,c]
[ac,t,w,_,t,c]
[ac,t,w,t,_,c]
[ac,t,w,t,c,_]
[_,t,w,t,c,ac]
[t,_,w,t,c,ac]
[t,w,_,t,c,ac]
[t,w,t,_,c,ac]
[t,w,t,c,_,ac]
[t,w,t,c,ac,_]
[_,w,t,c,ac,t]
[w,_,t,c,ac,t]
[w,t,_,c,ac,t]
[w,t,c,_,ac,t]
[w,t,c,ac,_,t]
[w,t,c,ac,t,_]
[_,t,c,ac,t,w]
[t,_,c,ac,t,w]
[t,c,_,ac,t,w]
[t,c,ac,_,t,w]
[_,c,ac,t,t,w]
[c,_,ac,t,t,w]
[c,ac,_,t,t,w]
[c,ac,t,_,t,w]
[c,ac,t,t,_,w]
[c,ac,t,t,w,_]
[_,ac,t,t,w,c]
[ac,_,t,t,w,c]
[ac,t,_,t,w,c]
[ac,t,t,_,w,c]
[ac,t,t,w,_,c]
[ac,t,t,w,c,_]
[_,t,t,w,c,ac]
[t,_,t,w,c,ac]
[t,t,_,w,c,ac]
[t,t,w,_,c,ac]
[t,t,w,c,_,ac]
[t,t,w,c,ac,_]
[_,t,w,c,ac,t]
[t,_,w,c,ac,t]
[t,w,_,c,ac,t]
[t,w,c,_,ac,t]
[t,w,c,ac,_,t]
[t,w,c,ac,t,_]
[_,w,c,ac,t,t]
[w,_,c,ac,t,t]
[w,c,_,ac,t,t]
[w,c,ac,_,t,t]
[w,c,ac,t,_,t]
[w,c,ac,t,t,_]
[w,c,_,t,t,ac]
[w,c,t,_,t,ac]
[w,c,t,t,_,ac]
[w,c,t,t,ac,_]
[_,c,t,t,ac,w]
[c,_,t,t,ac,w]
[c,t,_,t,ac,w]
[c,t,t,_,ac,w]
[c,t,t,ac,_,w]
[c,t,t,ac,w,_]
[_,t,t,ac,w,c]
[t,_,t,ac,w,c]
[t,t,_,ac,w,c]
[t,t,ac,_,w,c]
[t,t,ac,w,_,c]
[t,t,ac,w,c,_]
[_,t,ac,w,c,t]
[t,_,ac,w,c,t]
[t,ac,_,w,c,t]
[t,ac,w,_,c,t]
[t,ac,w,c,_,t]
[t,ac,w,c,t,_]
[_,ac,w,c,t,t]
[ac,_,w,c,t,t]
[ac,w,_,c,t,t]
[ac,w,c,_,t,t]
[ac,w,c,t,_,t]
[ac,w,c,t,t,_]
[_,w,c,t,t,ac]
[w,_,c,t,t,ac]
[w,t,c,t,_,ac]
[w,t,c,t,ac,_]
[_,t,c,t,ac,w]
[t,_,c,t,ac,w]
[t,c,_,t,ac,w]
[t,c,t,_,ac,w]
[t,c,t,ac,_,w]
[t,c,t,ac,w,_]
[_,c,t,ac,w,t]
[c,_,t,ac,w,t]
[c,t,_,ac,w,t]
[c,t,ac,_,w,t]
[c,t,ac,w,_,t]
[c,t,ac,w,t,_]
[_,t,ac,w,t,c]
[t,_,ac,w,t,c]
[t,ac,_,w,t,c]
[t,ac,w,_,t,c]
[t,ac,w,t,_,c]
[t,ac,w,t,c,_]
[_,ac,w,t,c,t]
[ac,_,w,t,c,t]
[ac,w,_,t,c,t]
[ac,w,t,_,c,t]
[ac,w,t,c,_,t]
[ac,w,t,c,t,_]
[_,w,t,c,t,ac]
[w,_,t,c,t,ac]
[w,t,_,c,t,ac]
[w,t,c,_,t,ac]
[_,t,c,w,t,ac]
[t,_,c,w,t,ac]
[t,c,_,w,t,ac]
[t,c,w,_,t,ac]
[t,c,w,t,_,ac]

TIME: 0.9562380313873291

true .

?- roomBF(["t", "c", "ac", "t", "_", "w"], ["t", "c", "w", "t", "_", "ac"]).

Breadth-first search

[t,c,ac,t,_,w]
[t,c,ac,t,w,_]
[_,c,ac,t,w,t]
[t,c,ac,_,w,t]
[t,c,ac,w,_,t]
[t,c,ac,w,t,_]
[t,c,_,w,t,ac]
[t,c,w,_,t,ac]
[t,c,w,t,_,ac]

TIME: 0.16299009323120117

true .

?- roomI(["t", "c", "ac", "t", "_", "w"], ["t", "c", "w", "t", "_", "ac"]).

Iterative deepening search

[t,c,ac,t,_,w]
[t,c,ac,t,w,_]
[_,c,ac,t,w,t]
[t,c,ac,_,w,t]
[t,c,ac,w,_,t]
[t,c,ac,w,t,_]
[t,c,_,w,t,ac]
[t,c,w,_,t,ac]
[t,c,w,t,_,ac]

TIME: 0.08586001396179199

true.
```

Другие тесты:
```prolog
?- roomI(["t", "c", "_", "w"], ["t", "c", "w", "_"]).

Iterative deepening search

[t,c,_,w]
[t,c,w,_]

TIME: 0.013580799102783203

true .

?- roomBF(["t", "c", "ac", "t", "_", "w"], ["t", "c", "ac", "t", "_", "w"]).

Breadth-first search

[t,c,ac,t,_,w]

TIME: 0.008810043334960938

true .

?- roomDF([], []).

Depth-first search

[]

TIME: 0.005964040756225586

true .
```

## Выводы

Сформулируйте *содержательные* выводы по лабораторной работе. 
Чему она вас научила? Над чем заставила задуматься? 

Какие алгоритмы поиска в каких случаях удобно использовать? Какие оказались оптимальными в вашем конкретном случае?

Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную.




